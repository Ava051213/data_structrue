# 常用实用类

## 7.1 Date类

### 基本概念
- 位于`java.util`包，表示时间戳
- 表示相对1970年1月1日0点(GMT)的时间
- 注意：大部分方法已过时，Java 8+推荐使用`java.time`包
- 内部存储从1970年1月1日开始的毫秒数

### 创建对象
```java
// 无参构造：当前时间
Date date = new Date();

// 毫秒构造：指定时间点
Date date1 = new Date(System.currentTimeMillis());
Date date2 = new Date(60*60*1000); // 1小时后

// 已过时构造方法（年份=实际年份-1900，月份从0开始）
Date date3 = new Date(124, 8, 22); // 2024年9月22日
```

### 日期比较
```java
if(date1.before(date2)) {...}
if(date1.after(date2)) {...}
if(date1.equals(date2)) {...}

// 使用compareTo
int result = date1.compareTo(date2);
```

### 格式化时间
```java
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
String formatted = sdf.format(new Date());
```

### 时间元字符表
| 字符 | 功能 | 示例 | 说明 |
|------|------|------|------|
| yyyy | 4位年份 | 2024 | 完整年份表示 |
| MM | 2位月份 | 08 | 01-12 |
| dd | 2位日期 | 09 | 01-31 |
| HH | 24小时制 | 15 | 00-23 |
| mm | 分钟 | 30 | 00-59 |
| ss | 秒 | 45 | 00-59 |
>注：关于pattern中的普通字符，如果是ASCII字符集中的字符，必须用""转义符

## 7.2 Calendar类

### 基本概念
- 位于`java.util`包，用于复杂日期计算
- 通过`getInstance()`获取实例
- 月份从0开始（0=一月，11=十二月）

### 常用操作
```java
Calendar cal = Calendar.getInstance();
cal.set(2024, Calendar.SEPTEMBER, 22); // 设置日期
int year = cal.get(Calendar.YEAR);     // 获取年份
```

### 实用方法
```java
// 获取月份天数
int daysInMonth = cal.getActualMaximum(Calendar.DAY_OF_MONTH);

// 判断闰年
boolean isLeap = cal.getActualMaximum(Calendar.DAY_OF_YEAR) > 365;
```

## 7.3 Math类与BigInteger类

### Math类静态常量
```java
Math.PI   // 3.141592653589793
Math.E    // 2.718281828459045
```

### 常用方法
| 方法       | 功能       | 示例                  |
| -------- | -------- | ------------------- |
| abs(x)   | 绝对值      | Math.abs(-5) → 5    |
| max(a,b) | 最大值      | Math.max(3,7) → 7   |
| min(a,b) | 最小值      | Math.min(3,7) → 3   |
| pow(a,b) | a的b次幂    | Math.pow(2,3) → 8.0 |
| random() | [0,1)随机数 | Math.random()       |
| sqrt(x)  | 平方根      | Math.sqrt(9) → 3.0  |
- 三角函数
```Java
Math.sin(Math.PI/6)  // 正弦函数 → 0.5
Math.cos(Math.PI/3)  // 余弦函数 → 0.5
Math.tan(Math.PI/4)  // 正切函数 → 1.0
```
- 随机数生成
```Java
// 生成[0,1)范围内的随机double值
double random = Math.random(); 

// 生成1-100的随机整数
int randInt = (int)(Math.random()*100)+1;
```

### BigInteger类
- 创建大整数对象：
```Java
// 从字符串构造（十进制）
BigInteger big1 = new BigInteger("12345678901234567890");

// 从字节数组构造
byte[] bytes = {0x1F, 0x2A};
BigInteger big2 = new BigInteger(bytes);  // → 7978
```
- 算术运算
```Java
BigInteger a = new BigInteger("123456789");
BigInteger b = new BigInteger("987654321");

BigInteger sum = a.add(b);      // 加法
BigInteger diff = a.subtract(b); // 减法
BigInteger product = a.multiply(b); // 乘法
BigInteger quotient = a.divide(b);  // 除法
BigInteger remainder = a.remainder(b); // 取余
```
- 比较运算
```Java
int result = big1.compareTo(big2);
// 返回：1（大于）、0（等于）、-1（小于）
```
- 数制转换
```Java
// 转换为2进制字符串
String binary = big1.toString(2); 

// 转换为16进制字符串
String hex = big1.toString(16);
```

## 7.4 数字格式化

### NumberFormat类
- 抽象基类，提供数字格式化的通用接口
- 主要子类：
	- DecimalFormat：自定义格式
	- ChoiceFormat：区间匹配格式

### 基础用法
```java
// 获取默认区域格式实例
NumberFormat nf = NumberFormat.getInstance();
nf.setMaximumFractionDigits(3);
String result = nf.format(1234.5678); // "1,234.568"

// 获取百分比格式
NumberFormat percentFormat = NumberFormat.getPercentInstance();
percentFormat.setMinimumFractionDigits(1);
String percent = percentFormat.format(0.85); // "85.0%"

// 获取货币格式
NumberFormat currencyFormat = NumberFormat.getCurrencyInstance(Locale.US);
String money = currencyFormat.format(1234.5); // "$1,234.50"
```

### DecimalFormat模式
| 符号 | 含义 | 示例 |
|------|------|------|
| 0 | 数字，不足补零 | "000.00" → 123.5 → "123.50" |
| # | 数字，不补零 | "###.##" → 123.5 → "123.5" |
| . | 小数点分隔符 | |
| , | 分组分隔符 | |
| % | 百分比 | 0.85 → "85%" |
| ¤ | 货币符号 | |
```java
DecimalFormat df1 = new DecimalFormat("###,###.##");
df1.format(12345.678); // "12,345.68"

DecimalFormat df2 = new DecimalFormat("000000.000");
df2.format(123.45); // "000123.450"
```

### 舍入模式控制
```Java
DecimalFormat df = new DecimalFormat("#.##");
df.setRoundingMode(RoundingMode.HALF_UP); // 四舍五入
df.format(2.345); // "2.35"

df.setRoundingMode(RoundingMode.DOWN); // 直接截断
df.format(2.349); // "2.34"
```

## 7.5 LinkedList<E>泛型类

### 双向链表特性
- 每个节点包含：
	- E item
	- Node<E> prev
	- Node<E> next

#### 时间复杂度分析
| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| add(E e) | O(1) | 尾部添加 |
| add(int index, E e) | O(n) | 需要遍历到指定位置 |
| get(int index) | O(n) | 需要遍历 |
| remove(int index) | O(n) | 需要遍历 |
| removeFirst/Last() | O(1) | 直接操作头尾节点 |

#### 用法示例
```java
LinkedList<String> list = new LinkedList<>();

// 作为栈使用
list.push("A"); // 压栈
String top = list.pop(); // 弹栈

// 作为队列使用
list.offer("B"); // 入队
String head = list.poll(); // 出队

// 双向队列操作
list.addFirst("C");
list.addLast("D");
String first = list.removeFirst();
String last = list.removeLast();

// 迭代器反向遍历
Iterator<String> it = list.descendingIterator();
while(it.hasNext()) {
    System.out.println(it.next());
}
```

## 7.6 HashSet<E>泛型类

### 哈希表实现原理
- 基于HashMap实现
- 实际存储结构：HashMap<E,Object>
- 默认初始容量：16
- 加载因子：0.75（容量达到75%时自动扩容）
> HashSet<E>泛型类实现了泛型接口Set<E>，而Set<E>接口是Collection<E>接口的子接口

#### 性能影响因素
1. 哈希函数质量
2. 冲突解决策略（链表→红黑树）
3. 初始容量设置

```Java
// 优化初始容量
Set<String> largeSet = new HashSet<>(1000);

// 集合的交、并与差
boolean addAll(HashSet set);
boolean retainAll(HashSet set);
boolean removeAll(HashSet set);

// 自定义对象需重写hashCode和equals
class Student {
    String id;
    String name;
    
    @Override
    public int hashCode() {
        return Objects.hash(id, name);
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Student)) return false;
        Student s = (Student) o;
        return id.equals(s.id) && name.equals(s.name);
    }
}
```

#### 常用方法
|方法签名|核心功能说明|
|---|---|
|`boolean add(E o)`|添加指定元素（成功返回`true`）|
|`void clear()`|清空集合所有元素|
|`boolean contains(Object o)`|判断是否包含指定元素|
|`boolean isEmpty()`|判断集合是否为空|
|`boolean remove(Object o)`|删除指定元素（成功返回`true`）|
|`int size()`|返回元素个数|
|`Object[] toArray()`|转换为Object数组并返回|
|`boolean containsAll(HashSet set)`|判断是否包含参数集合所有元素|
|`Object clone()`|返回集合克隆对象（元素独立）|

## 7.7 HashMap<K,V>泛型类

### 实现机制
- 数组+链表+红黑树结构
- 当链表长度>8时转为红黑树
- 当红黑树节点<6时转回链表

#### 常用方法
|方法签名|核心功能总结|
|---|---|
|`void clear()`|清空散列映射中所有键值对|
|`Object clone()`|克隆当前散列映射，返回副本引用|
|`boolean containsKey(Object key)`|判断映射中是否包含指定键（存在则返回true）|
|`boolean containsValue(Object value)`|判断映射中是否包含指定值（存在则返回true）|
|`V get(Object key)`|根据指定键获取对应的值（无此键返回null）|
|`boolean isEmpty()`|判断映射是否为空（无键值对返回true）|
|`V remove(Object key)`|根据指定键删除键值对，返回被删除的键对应的值|
|`int size()`|获取映射的大小（返回键值对的总个数）|

#### 遍历散列映射
- 核心方法：`Collections<V> values()`
	- 返回存储映射中所有值的Collection集合（接口类型接收）
- 遍历逻辑：
	- 用`value()`方法获取值集合
	- 通过集合获取`Iterator`迭代器，遍历输出所有值

#### 关键参数
```java
// 查看实现细节
HashMap<String, Integer> map = new HashMap<>();
map.put("a", 1);

// 获取内部参数（反射实现）
Field tableField = HashMap.class.getDeclaredField("table");
tableField.setAccessible(true);
Object[] table = (Object[]) tableField.get(map);
System.out.println("桶数量: " + table.length);
```

#### 并发问题解决方案
```java
// 1. Collections同步包装
Map<String, Integer> syncMap = Collections.synchronizedMap(new HashMap<>());

// 2. ConcurrentHashMap（推荐）
ConcurrentHashMap<String, Integer> concurrentMap = new ConcurrentHashMap<>();

// 3. 读写锁控制
ReadWriteLock lock = new ReentrantReadWriteLock();
lock.writeLock().lock();
try {
    map.put("key", 1);
} finally {
    lock.writeLock().unlock();
}
```

## 7.8 TreeSet<E>泛型类

### 核心特性
1. 实现`Set`接口，存储无重复元素（基于排序规则判断重复）
2. 元素自动排序：默认按对象字符串表示升序，可自定义排序规则
3. 底层基于红黑树，排序和查找效率高

### 常用方法
|方法签名|核心功能|
|---|---|
|`boolean add(E o)`|添加元素，成功返回true（重复元素返回false）|
|`void clear()`|清空树集中所有元素|
|`boolean contains(Object o)`|判断树集是否包含指定元素（返回true/false）|
|`E first()`|返回排序后第一个元素（最小元素）|
|`E last()`|返回排序后最后一个元素（最大元素）|
|`boolean isEmpty()`|判断树集是否为空（空返回false）|
|`boolean remove(Object o)`|删除指定元素，成功返回true|
|`int size()`|返回树集中元素的个数|

### 自定义排序规则

#### 实现Comparable接口（元素类自身实现排序）
- 要求：存储的元素类实现`java.lang.Comparable`接口，重写`compareTo(Object o)`方法
- 核心逻辑：
	- 返回负数：当前对象 < 参数对象（排在前面）
	- 返回正数：当前对象 > 参数对象（排在后面）
	- 返回0：当前对象 = 参数对象（视为重复，不添加到树集）
- 示例：
```Java
class Student implements Comparable<Student> {
    String name;
    int score;
    @Override
    public int compareTo(Student stu) {
        // 按分数升序排列；分数相同返回1（允许重复分数）
        return this.score == stu.score ? 1 : this.score - stu.score;
    }
}
// 使用：直接创建TreeSet，自动按compareTo规则排序
TreeSet<Student> mytree = new TreeSet<>();
```

#### 实现Comparator接口（外部自定义排序器）
- 要求：创建`java.util.Comparator`接口实现类，重写`compare(Object o1,Object o2)`方法
- 核心逻辑：
	- 与`compareTo`一致（负数：o1在前；正数：o2在前；0：视为重复）
- 使用场景：
	- 元素类无法修改（未实现Comparable）
	- 需多种排序规则（不改变元素类）
- 示例：
```Java
// 自定义排序器：按分数升序
class StudentComparator implements Comparator<Student> {
    @Override
    public int compare(Student s1, Student s2) {
        return s1.score - s2.score;
    }
}
// 使用：创建TreeSet时传入排序器
TreeSet<Student> mytree = new TreeSet<>(new StudentComparator());
```

## 7.9 TreeMap<K,V>

### 核心特性
1. 实现`Map`接口，存储键值对（K-V）数据
2. 无重复键：基于排序规则判定键的唯一性
3. 自动排序：键（K）按指定规则升序排列，底层基于红黑树实现，查询/排序效率高
4. 与HashMap区别：TreeMap有序（键排序），HashMap无序（哈希散列）
> 空键支持：TreeMap不允许键为null（会抛出NullPointerException），HashMap允许一个null键

### 构造方法
|构造方法|核心说明|
|---|---|
|`TreeMap<K,V>()`|默认构造：按键的字符串字典顺序排序|
|`TreeMap<K,V>(Comparator<K> comp)`|自定义排序：按传入的Comparator接口规则排序键|

### 常用核心方法
|方法签名|核心功能|
|---|---|
|`V put(K key,V value)`|添加键值对：键不存在则新增，存在则覆盖值|
|`void clear()`|清空所有键值对|
|`boolean containsKey(Object key)`|判断是否包含指定键（返回true/false）|
|`boolean containsValue(Object value)`|判断是否包含指定值（返回true/false）|
|`V get(Object key)`|根据键获取对应值（无此键返回null）|
|`boolean isEmpty()`|判断映射是否为空（空返回true）|
|`V remove(Object key)`|根据键删除键值对，返回被删除的值|
|`int size()`|返回键值对的个数|
|`Collection<V> values()`|返回所有值的Collection集合（用于遍历值）|

### 键的排序规则

#### 键类实现Comparable接口
- 要求：作为键的类实现`java.lang.Comparable`接口，重写`compareTo(Object o)`方法
- 核心逻辑：
	- 返回负数：当前键 < 参数键（排在前面）
	- 返回正数：当前键 > 参数键（排在后面）
	- 返回0：当前键 = 参数键（视为重复键，put时会覆盖原值）
- 示例：
```Java
class MyKey implements Comparable<MyKey> {
    int number;
    @Override
    public int compareTo(MyKey o) {
        // 按 number 升序；number 相同返回1（避免视为重复键）
        return this.number == o.number ? 1 : this.number - o.number;
    }
}
// 使用：直接创建 TreeMap，键按 compareTo 规则排序
TreeMap<MyKey, Student> treemap = new TreeMap<>();
```

#### 传入Comparator接口（外部自定义排序器）
- 要求：创建`java.util.Comparator`接口实现类，重写`compare(K o1,K o2)`方法
- 核心逻辑：与`compareTo`一致（负数：o1在前；正数：o2在前；0：视为重复键）
- 适用场景：
	- 键类无法修改（未实现Comparable）
	- 需多种键排序规则（不改变键类）
- 示例：
```Java
// 自定义排序器：按 MyKey 的 number 降序
class MyKeyComparator implements Comparator<MyKey> {
    @Override
    public int compare(MyKey k1, MyKey k2) {
        return k2.number - k1.number; // 降序（反转升序逻辑）
    }
}
// 使用：创建 TreeMap 时传入排序器
TreeMap<MyKey, Student> treemap = new TreeMap<>(new MyKeyComparator());
```

## 7.10 Stack<E>泛型类

### 核心特性
1. 数据结构：后进先出（LIFO），仅允许在栈顶进行数据操作
2. 继承关系：继承自`Vector`类，线程安全（但效率较低，JDK1.6+推荐用`Deque`替代）
3. 核心操作：压栈（入栈）、弹栈（出栈）、查看栈顶元素

### 常用核心方法
|方法签名|核心功能|注意事项|
|---|---|---|
|`E push(E item)`|压栈：将元素添加到栈顶|返回添加的元素本身|
|`E pop()`|弹栈：移除并返回栈顶元素|栈为空时抛出`EmptyStackException`|
|`E peek()`|查看栈顶元素：返回栈顶元素但不删除|栈为空时抛出`EmptyStackException`|
|`boolean empty()`|判断栈是否为空：空返回true，否则false|无|
|`int search(Object data)`|查找元素位置：返回元素在栈中的索引（栈顶为1，向下递增）|元素不存在返回-1|

### 代码示例
```Java
import java.util.Stack;

public class StackDemo {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();
        // 初始化：压入斐波那契前两项（1, 1）
        stack.push(1);
        stack.push(1);
        
        int k = 1;
        // 生成后续5项斐波那契数
        while (k <= 5) {
            int f1 = stack.pop(); // 弹出栈顶（第n项）
            int f2 = stack.pop(); // 弹出次栈顶（第n-1项）
            int next = f1 + f2;   // 计算第n+1项
            System.out.println("第" + (k + 2) + "项斐波那契数：" + next);
            
            stack.push(f2); // 压回第n-1项（供下次计算使用）
            stack.push(next); // 压入新计算的第n+1项
            k++;
        }
    }
}
```
- **说明**：
	- 线程安全与效率：`Stack`基于`Vector`实现，所有方法加了`synchronized`锁，线程安全但效率低；非并发场景推荐用`Deque`接口的`push()`/`pop()`方法替代
	- 空栈异常：`pop()`和`peek()`在栈为空时会抛出`EmptyStackException`，使用前需通过`empty()`判空
	- 查找规则：`search()`方法从栈顶开始计数（栈顶为1），而非数组的0索引
	- 应用场景：递归算法优化（消除递归）、表达式求值、括号匹配校验等

