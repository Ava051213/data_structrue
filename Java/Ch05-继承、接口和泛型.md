# 继承、接口和泛型

## 5.1 子类与父类

- **继承**是一种由已有的类创建类的机制
  - 利用继承，我们可以先创建一个共有属性的**一般类**，根据该一般类再创建具有特殊属性的**新类**
  - 新类继承一般类的属性和功能，并根据需要增加自己的新属性和功能
  - 由继承而得的类称为**子类**，被继承的类称为**父类**

- Java语法：
  ```java
  class 子类名 extends 父类名 {
      // 类体
  }
  ```
  - Java不支持多重继承（一个子类只能有一个父类）

## 5.2 子类的继承性

### 同一包中的继承
- 继承父类中非private的成员变量和方法
- 继承的成员变量和方法保持原访问权限

### 不同包中的继承
- 只能继承父类的protected和public成员
- 不能继承friendly成员变量和方法

## 5.3 子类对象的构造过程

- 子类构造方法总是先调用父类的某个构造方法
  - 未指定时默认调用父类无参构造方法
  - 父类构造方法不会被继承，仅能通过`super()`调用

- 子类对象包含：
  - 子类声明的成员变量
  - 父类继承的部分成员变量
  - 继承的方法
  >1. 父类的private成员变量会分配内存，但不归子类管理（不能直接访问）；不同包下父类的friendly成员也不作为子类成员
  >2. 父类未被继承的成员（如private变量）虽占内存，但子类无法直接操作；但父类继承来的方法可内部操作这些父类私有成员

## 5.4 成员变量隐藏和方法重写

### 成员变量隐藏
- 子类定义与父类同名的成员变量时，隐藏继承的变量

### 方法重写
- 子类定义与父类完全相同的方法（名称、返回类型、参数）
- 使用`super`可调用被隐藏的方法

### 访问修饰符protected
- 继承：可被直接/间接（多层）子类继承，与子父类是否同包有关
- 内部访问：自身/子孙类内，对象可通过”.“访问自身/继承的protected成员
- 跨类访问：关键看”包匹配“（与中间继承类的包无关）
>关键看是否在同一个包中

## 5.5 关键字super

两种用法：
1. 调用父类构造方法
   ```java
   super(参数); // 必须是子类构造方法的第一条语句
   ```
2. 操作被隐藏的成员变量和方法
   ```java
   super.成员变量;
   super.方法();
   ```

## 5.6 final类与final方法

| 类型 | 特点 | 示例 |
|------|------|------|
| final类 | 不能被继承 | `final class A {...}` |
| final方法 | 不能被子类重写 | `public final void f() {...}` |
- **说明**：
	- final类：防止继承修改/拓展，保障类的设计意图、内部不变性与安全性（如java.lang.String）
	- final方法：保持关键行为不变，同时支持编译器/JVM优化（如内联调用），因为方法不会被重写

## 5.7 对象的上转型对象

- 语法：
  ```java
  父类 对象A = new 子类(); // 上转型对象
  ```
- 特点：
  - 不能操作子类新增的成员变量和方法
  - 可以访问子类继承/隐藏的父类成员，调用继承或重写的父类方法
  - 支持强制转回子类类型，恢复子类所有属性和功能
- 优势：
  - 实现多态：允许同一接口处理不同对象，运行时动态绑定方法
  - 提供代码复用性：用父类类型编写通用方法
  - 降低耦合度：高层模块依赖于抽象（父类/接口）
  - 便于系统维护：修改具体实现不会影响高层业务逻辑

## 5.8 继承与多态

- 通过方法重写和上转型对象实现多态
- 示例：
  ```java
  Animal animal;
  animal = new Dog(); // 调用Dog的cry()
  animal = new Cat(); // 调用Cat的cry()
  ```

## 5.9 abstract类

- 用`abstract`修饰的类
- 特点：
  - 不能实例化，不能用new运算符创建对象
  - 可以包含抽象方法
  - 非抽象子类必须实现所有抽象方法
>抽象类可自定义构造方法，推荐用protected修饰（抽象类是需要继承的）

## 5.10 面向抽象编程

1. 将变化细节抽象为抽象方法
2. 通过继承抽象类实现具体功能

## 5.11 接口

- 定义：
  ```java
  interface 接口名 {
      // 常量（默认public static final，可省略）
      // 抽象方法（默认public abstract，可省略，无方法体）
  }
  ```
- 实现：
  ```java
  class 类名 implements 接口1, 接口2,... { // 支持多实现
	  // 重写所有接口的抽象方法
  }
  ```
- 特点：
  - 仅含常量和抽象方法，方法无实现（以分号结尾）
  - 实现类需要重写所有接口抽象方法（为全部实现则类需要声明为抽象类）
  - 重写接口方法必须显式用`public`修饰，不可省略
  - 接口可通过`extends`继承多个其他接口（支持接口多继承）

## 5.12 接口回调

- 实现多态的另一种方式，将实现接口的类对象引用赋给接口变量，通过该变量调用类实现的接口方法，即接口回调
- 方法参数为接口类型时，可传入实现该接口的类对象，通过参数回调调用接口方法
- 示例：
  ```java
  // 接口变量回调
  接口 变量 = new 实现类();
  变量.接口方法(); // 回调实现类的方法
  
  // 接口作参数回调
  class 类名 {
	  public void 方法名(接口名 参数名){
		  参数名.接口方法(); // 回调传入对象的实现方法
	  }
  }
  ```

## 5.13 面向接口编程

- 优点：
  - 降低耦合
  - 提高扩展性
  - 便于维护

## 5.14 抽象类与接口比较

| 特性   | 抽象类    | 接口     |
| ---- | ------ | ------ |
| 方法   | 可有具体方法 | 只有抽象方法 |
| 变量   | 可有普通变量 | 只有常量   |
| 继承   | 单继承    | 多实现    |
| 设计目的 | 代码复用   | 定义规范   |
>注：Java 8之后可以有默认方法（用default修饰）和静态方法（用static修饰）

## 5.15 内部类

- 定义在类内部的类
- 特点：
  - 可访问外部类成员
  - 不能有静态成员(除非static内部类)
  - 常用作事件处理器

## 5.16 匿名类
- 定义：无类名的内部类，类体与对象创建结合，本质是父类的子类或接口的实现类
- 语法：
```Java
// 基于类（父类/抽象类）
new 父类/抽象类() {
	// 重写方法、类体内容
};

// 基于接口
new 接口() {
	// 实现接口所有抽象方法、类体内容
};
```
- 特性：
	1. 不能单独声明对象，仅能直接创建匿名对象
	2. 属于内部类，可访问外嵌类成员，不可声明静态成员
	3. 主要用途：简化代码，直接向方法参数传递类/接口的实现对象

## 5.17 异常类

- 异常处理结构：
  ```java
  try {
      // 可能异常的代码
  } catch(异常类 e) {
      // 处理代码
  }
  ```
>注：多个catch的异常类不可有父子关系，否则仅需保留父类异常的catch

### 自定义异常
```Java
// 1.自定义异常类
class MyException extends Exception {
	public MyException(String msg) {
		super(msg);
	}
}

// 2.调用示例
try {
	// 可能抛出自定义异常的代码
	if(条件不满足) {
		throws new MyException("异常描述");
	}
}catch(MyException e) {
	// 处理自定义异常
	System.out.println("捕获异常："+e.getMessage());
}
```
1. 自定义类继承Exception类
2. 方法使用`throws`声明抛出异常，方法体内通过`throw new 异常对象()`触发异常
3. 把调用带`throws`声明的方法放在`try-catch`块中处理
>一个方法在声明时可以使用`throws`关键字声明抛出所要产生的若干个异常

## 5.18 泛型类

- 泛型类定义：
  ```java
  class 类名<泛型标识> { // 泛型标识可为E、T等，不能是基本类型
	  // 泛型标识可作为成员变量、方法参数/返回值类型
  }
  ```
- 泛型类使用：
  ```java
  类名<实际类型> 对象 = new 类名<实际类型>(); // 需指定具体引用类型
  ```
- 泛型接口定义与实现
```Java
interface 接口名<泛型标识> {
	// 泛型相关方法声明
}

class 实现类<泛型标识> implements 接口名<泛型标识> {
	// 实现接口方法
}
```
- 优点：
  - 类型安全：编译时检查类型，避免运行时类型转换错误
  - 减少冗余：无需手动类型转换，代码更间接
  - 通用性强：同一类/接口可适配不同引用类型，提高复用性
